<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Mystic Diamond 3D Art</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }

        /* 시작 화면 오버레이 */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #ccffff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            letter-spacing: 0.5rem;
            cursor: pointer;
            z-index: 100;
            transition: opacity 1.5s ease;
            text-transform: uppercase;
        }
        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Download UI */
        .download-ui {
            position: absolute;
            bottom: 40px;
            left: 40px;
            pointer-events: none;
            z-index: 90;
        }
        .download-ui * {
            pointer-events: auto;
        }
        .download-icon {
            display: inline-block;
            color: rgba(255, 255, 255, 0.7);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .download-icon:hover {
            color: #CCFF00; /* Neon Green */
            transform: translateY(-2px);
            filter: drop-shadow(0 0 5px rgba(204, 255, 0, 0.5));
        }
    </style>
    <script>
      window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</head>
<body>
    <div id="overlay">Click</div>
    <div class="download-ui">
        <a href="/ticket/?artwork=dimension-prism" class="download-icon" aria-label="Get Ticket">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        </a>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';
        
        // Post-processing
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // 1. 기본 씬 설정 (Scene Setup)
        const scene = new THREE.Scene();
        // 안개 효과를 주어 파티클이 멀어질 때 자연스럽게 흐려지게 함
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // 빛나는 효과를 위해 픽셀 비율 조정
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Post Processing Setup ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom Pass (Strength, Radius, Threshold)
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.2,  // strength (빛 번짐 강도)
            0.1,  // radius (빛 번짐 반경)
            1    // threshold (빛 번짐이 시작되는 밝기 임계값, 0이면 모든 밝기에서 번짐)
        );
        composer.addPass(bloomPass);

        // Color correction / Output pass
        const outputPass = new OutputPass();
        composer.addPass(outputPass);
        // -----------------------------


        // 2. 다이아몬드 (타임터너) 구조체 만들기
        const diamondGroup = new THREE.Group();
        scene.add(diamondGroup);

        const rings = [];

        function createDiamondRing(size, color, opacity, lineWidth, noiseScale = 0.8) {
            const geometry = new THREE.OctahedronGeometry(size, 0); 
            const edges = new THREE.EdgesGeometry(geometry);
            
            // Fat Lines를 위한 Geometry 생성
            const lineGeometry = new LineSegmentsGeometry();
            lineGeometry.setPositions(edges.attributes.position.array);

            const material = new LineMaterial({ 
                color: color,
                linewidth: lineWidth, // 실제 굵기 적용 가능
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight), // 해상도 필수
                transparent: true,
                opacity: opacity,
                blending: THREE.AdditiveBlending,
                depthTest: false // 겹쳐 보일 때 더 예쁘게
            });
            
            // 쉐이더 커스터마이징: 노이즈 텍스처 효과 추가
            material.onBeforeCompile = function(shader) {
                // Vertex Shader 수정: 월드 좌표 계산하여 Varying으로 넘기기
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <common>',
                    `
                    #include <common>
                    varying vec3 vMyWorldPos;
                    `
                );
                
                // main 함수 내에 월드 좌표 계산 로직 주입
                // LineMaterial의 vertex shader 구조를 고려하여 적절한 위치에 삽입
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <fog_vertex>',
                    `
                    #include <fog_vertex>
                    // instanceStart/End는 로컬 좌표일 수 있으므로 모델 행렬 곱셈 필요
                    // position.y < 0.5 이면 start점, 아니면 end점
                    vec4 wStart = modelMatrix * vec4( instanceStart, 1.0 );
                    vec4 wEnd = modelMatrix * vec4( instanceEnd, 1.0 );
                    vMyWorldPos = ( position.y < 0.5 ) ? wStart.xyz : wEnd.xyz;
                    `
                );

                // Fragment Shader 수정: 노이즈 함수 추가 및 Alpha 변조
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <common>',
                    `
                    #include <common>
                    varying vec3 vMyWorldPos;
                    
                    // Simplex Noise (3D) Helper
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) {
                        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

                        // First corner
                        vec3 i  = floor(v + dot(v, C.yyy) );
                        vec3 x0 = v - i + dot(i, C.xxx) ;

                        // Other corners
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min( g.xyz, l.zxy );
                        vec3 i2 = max( g.xyz, l.zxy );

                        //   x0 = x0 - 0.0 + 0.0 * C.xxx;
                        //   x1 = x0 - i1  + 1.0 * C.xxx;
                        //   x2 = x0 - i2  + 2.0 * C.xxx;
                        //   x3 = x0 - 1.0 + 3.0 * C.xxx;
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

                        // Permutations
                        i = mod289(i); 
                        vec4 p = permute( permute( permute( 
                                    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                                + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

                        // Gradients: 7x7 points over a square, mapped onto an octahedron.
                        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
                        float n_ = 0.142857142857; // 1.0/7.0
                        vec3  ns = n_ * D.wyz - D.xzx;

                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);

                        vec4 b0 = vec4( x.xy, y.xy );
                        vec4 b1 = vec4( x.zw, y.zw );

                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));

                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);

                        //Normalise gradients
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;

                        // Mix final noise value
                        vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                        dot(p2,x2), dot(p3,x3) ) );
                    }
                    `
                );

                // Main 함수 내에서 Noise 적용 (Alpha 변조)
                shader.fragmentShader = shader.fragmentShader.replace(
                    'gl_FragColor = vec4( diffuseColor.rgb, alpha );',
                    `
                    // 노이즈 스케일 조정 (숫자가 클수록 자글자글함)
                    // noiseScale 파라미터 적용 (default 0.8)
                    // 0.0에 가까우면 노이즈가 거의 없어짐 (아주 넓게 퍼짐)
                    float n = snoise(vMyWorldPos * ${Number(noiseScale).toFixed(2)});
                    
                    // 노이즈를 0~1 범위로 조정하고 대비를 줌
                    float noiseVal = 0.5 + 0.5 * n;
                    
                    // Alpha에 노이즈 반영 (불규칙하게 끊어지거나 흐려지게)
                    // noiseVal이 낮으면 투명해지도록
                    float noisyAlpha = alpha * smoothstep(0.2, 0.9, noiseVal); 
                    
                    gl_FragColor = vec4( diffuseColor.rgb, noisyAlpha );
                    `
                );
            };
            
            const mesh = new LineSegments2(lineGeometry, material);
            mesh.computeLineDistances();
            mesh.scale.set(1, 1, 1);
            
            return mesh;
        }

        // 크기가 다른 6개의 다이아몬드 생성
        // 안쪽 (가장 빠름) -> 굵게 (3~4), 노이즈 적게 (0.1)
        const ring0 = createDiamondRing(0.2, 0xffffff, 3.0, 3, 0.1); 
        const ring1 = createDiamondRing(0.5, 0xe0ffff, 2.5, 2.5); // 기본값 0.8
        const ring2 = createDiamondRing(0.7, 0xccffff, 1.5, 2); 

        // 바깥쪽 (조금 더 느림) -> 얇게 (1~2)
        const ring4 = createDiamondRing(1.2, 0x88ffff, 0.4, 1.5); 
        const ring5 = createDiamondRing(1.5, 0x66ffff, 0.2, 0.8); 
        ring5.scale.set(1, 1.5, 1);

        diamondGroup.add(ring0);
        diamondGroup.add(ring1);
        diamondGroup.add(ring2);
        diamondGroup.add(ring4);
        diamondGroup.add(ring5);

        rings.push(ring0, ring1, ring2, ring4, ring5);

        // 초기 회전 각도 랜덤 설정 (ring5는 바로 세움)
        rings.forEach(ring => {
            if (ring === ring5) return;
            ring.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
        });
        ring5.rotation.set(0, 0, 0);


        // 3. 퍼지는 파티클 시스템 (Particle System)
        const particleCount = 1000;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = []; // 각 파티클의 속도 저장

        for (let i = 0; i < particleCount; i++) {
            // 초기 위치: 중앙 근처 랜덤
            positions[i * 3] = (Math.random() - 0.5) * 2;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 2;

            // 속도: 바깥으로 퍼져나가는 랜덤 벡터 (속도를 줄임 0.003 -> 0.0008)
            velocities.push({
                x: (Math.random() - 0.5) * 0.005,
                y: (Math.random() - 0.5) * 0.005,
                z: (Math.random() - 0.5) * 0.005
            });
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // 커스텀 쉐이더: 거리에 따라 투명해지고 작아짐
        const particlesMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xccffff) }
            },
            vertexShader: `
                varying float vAlpha;
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // 중심에서의 거리 계산
                    float dist = length(position);
                    
                    // 최대 거리 (이 거리에서 완전히 사라짐)
                    float maxDist = 10.0; 
                    
                    // 거리가 멀어질수록 알파값 감소
                    vAlpha = 1.0 - smoothstep(0.0, maxDist, dist);
                    
                    // 거리에 따라 크기도 작아지게 설정 (원근감 + 거리 감쇠)
                    gl_PointSize = (30.0 * vAlpha) / -mvPosition.z;
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                varying float vAlpha;
                void main() {
                    // 원형 파티클 만들기
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if (r > 0.5) discard;
                
                    gl_FragColor = vec4(color, vAlpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);

        // --- 5. 궤도 파티클 시스템 (Orbiting Particles) ---
        const orbitCount = 100;
        const orbitGeometry = new THREE.BufferGeometry();
        const orbitPositions = new Float32Array(orbitCount * 3);
        const orbitData = []; // 각 파티클의 움직임 정보

        for(let i=0; i<orbitCount; i++) {
            // 구형 분포 (Spherical Distribution)
            // 랜덤한 위치에 배치 (반경 0.5 ~ 2.0 사이로 좁혀서 중심에 집중)
            const r = 0.1 + Math.random() * 1.2;
            const theta = Math.random() * Math.PI * 2; // xy 평면 각도
            const phi = Math.acos((Math.random() * 2) - 1); // z축 각도
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            orbitPositions[i*3] = x;
            orbitPositions[i*3+1] = y;
            orbitPositions[i*3+2] = z;

            // 각 파티클마다 고유한 부유(floating) 움직임 설정
            orbitData.push({
                initialX: x,
                initialY: y,
                initialZ: z,
                // 랜덤한 위상(phase)과 속도
                phase: Math.random() * Math.PI * 2,
                speed: 0.002 + Math.random() * 0.005,
                // 움직임 범위
                ampX: (Math.random() - 0.5) * 0.5,
                ampY: (Math.random() - 0.5) * 0.5,
                ampZ: (Math.random() - 0.5) * 0.5
            });
        }
        orbitGeometry.setAttribute('position', new THREE.BufferAttribute(orbitPositions, 3));

        // 궤도 파티클용 머티리얼 (약간 다른 색상/크기)
        const orbitMaterial = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xccffff) } // 메인 색상(Cyan)과 동일하게 맞춤
            },
            // 기존 Vertex Shader를 복사하되, PointSize multiplier를 35.0으로 키움
            vertexShader: `
                varying float vAlpha;
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    float dist = length(position);
                    float maxDist = 10.0; 
                    vAlpha = 1.0 - smoothstep(0.0, maxDist, dist);
                    
                    // 궤도 파티클은 조금 더 크게 (기존 20.0 -> 35.0)
                    gl_PointSize = (35.0 * vAlpha) / -mvPosition.z;
                }
            `,
            fragmentShader: particlesMaterial.fragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const orbitSystem = new THREE.Points(orbitGeometry, orbitMaterial);
        scene.add(orbitSystem);

        function updateOrbitParticles() {
            const positions = orbitSystem.geometry.attributes.position.array;
            const time = Date.now() * 0.001; // 현재 시간 (초 단위)
            
            for(let i=0; i<orbitCount; i++) {
                const data = orbitData[i];
                
                // 사인파를 이용한 부유(Floating) 효과
                // 원래 위치를 기준으로 위아래/좌우로 천천히 흔들림
                positions[i*3]   = data.initialX + Math.sin(time * data.speed + data.phase) * data.ampX;
                positions[i*3+1] = data.initialY + Math.cos(time * data.speed + data.phase) * data.ampY;
                positions[i*3+2] = data.initialZ + Math.sin(time * data.speed * 0.5 + data.phase) * data.ampZ;
            }
            // 전체 덩어리도 천천히 회전시켜서 계속 변하는 느낌 주기
            orbitSystem.rotation.y -= 0.0005;
            orbitSystem.rotation.z += 0.0002;
            
            orbitSystem.geometry.attributes.position.needsUpdate = true;
        }
        // -----------------------------------------------------

        // 파티클 움직임 로직을 분리한 함수
        function updateParticles(speedScale = 1.0) {
            const positions = particleSystem.geometry.attributes.position.array;

            for (let i = 0; i < particleCount; i++) {
                // 현재 위치에 속도 더하기 (speedScale 적용)
                positions[i * 3] += velocities[i].x * speedScale;
                positions[i * 3 + 1] += velocities[i].y * speedScale;
                positions[i * 3 + 2] += velocities[i].z * speedScale;

                // 중앙에서 너무 멀어지면(사라지면) 다시 중앙으로 리셋 (순환 효과)
                const dist = Math.sqrt(
                    positions[i * 3] ** 2 + 
                    positions[i * 3 + 1] ** 2 + 
                    positions[i * 3 + 2] ** 2
                );

                // 쉐이더의 maxDist(4.0)보다 살짝 더 멀리 갔을 때 리셋하여 자연스럽게 사라진 후 나타나게 함
                if (dist > 4.5) { 
                    positions[i * 3] = (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
                }
            }
            // 위치 데이터가 변경되었음을 Three.js에 알림
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        // [Pre-warming] 애니메이션 시작 전 미리 시뮬레이션을 돌려 파티클을 퍼뜨려 놓음
        for(let i=0; i<300; i++) {
            updateParticles();
        }


        const clock = new THREE.Clock();

        // 링 펄스 애니메이션 변수 (클릭에 맞춰 트리거)
        let ringPulseTime = 0;
        const ringPulseDuration = 0.8;

        // Bloom pulse 애니메이션 변수
        let bloomPulseTime = 0;
        const bloomPulseDuration = 0.8; // 펄스 지속 시간 (초)
        const baseBloomStrength = 0.5;
        const maxBloomStrength = 0.6;

        // Bloom pulse 함수
        function triggerBloomPulse() {
            bloomPulseTime = bloomPulseDuration;
        }

        function triggerRingPulse() {
            ringPulseTime = ringPulseDuration;
        }

        // 4. 애니메이션 루프 (Animation Loop)
        function animate() {
            requestAnimationFrame(animate);

            // FPS가 떨어져도 속도를 일정하게 유지하기 위해 delta time 사용
            const delta = clock.getDelta();
            
            // 클릭에 맞춘 링 펄스 (짧게 커졌다 작아짐)
            if (ringPulseTime > 0) {
                ringPulseTime -= delta;
            }
            const ringProgress = ringPulseTime > 0 ? ringPulseTime / ringPulseDuration : 0;
            const pulseAmount = Math.pow(ringProgress, 3);
            const pulseScale = 1.0 + pulseAmount * 0.05;
            diamondGroup.scale.set(pulseScale, pulseScale, pulseScale);

            // Bloom pulse 애니메이션
            if (bloomPulseTime > 0) {
                bloomPulseTime -= delta;
                const progress = 1.0 - (bloomPulseTime / bloomPulseDuration);
                const easedProgress = 1.0 - Math.pow(1.0 - progress, 3);
                bloomPass.strength =
                    baseBloomStrength +
                    (maxBloomStrength - baseBloomStrength) * (1.0 - easedProgress);
            } else {
                bloomPass.strength = baseBloomStrength;
            }

            // 원래 60fps 기준으로 설계된 수치들이므로, delta에 60을 곱하여 보정
            // delta가 0.016(60fps)일 때 speedScale은 1.0이 됨
            const speedScale = delta * 60 * 3;

            // [타임터너 회전] 안쪽은 빠르게, 바깥쪽은 천천히
            
            // 안쪽 그룹 (빠름)
            ring0.rotation.x += 0.02 * speedScale;
            ring0.rotation.z -= 0.04 * speedScale;

            ring1.rotation.x += 0.01 * speedScale;
            ring1.rotation.y += 0.008 * speedScale;

            ring2.rotation.y -= 0.008 * speedScale;
            ring2.rotation.z += 0.006 * speedScale;

            // 바깥쪽 그룹 (느림)
            ring4.rotation.y += 0.003 * speedScale;
            ring4.rotation.x -= 0.002 * speedScale;

            ring5.rotation.z += 0 * speedScale;
            ring5.rotation.y += 0.001 * speedScale;

            // [파티클 움직임]
            // updateParticles 함수에 speedScale 전달하여 프레임 레이트 독립성 확보
            updateParticles(speedScale); 
            updateOrbitParticles();
            
            // 전체 파티클 덩어리도 천천히 회전
            particleSystem.rotation.y += 0.0005 * speedScale;
            orbitSystem.rotation.y -= 0.0005 * speedScale;
            orbitSystem.rotation.z += 0.0002 * speedScale;

            // renderer.render(scene, camera) 대신 composer 사용
            composer.render();
        }

        // 창 크기 조절 대응
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            // Fat Lines Material의 해상도 업데이트
            const res = new THREE.Vector2(width, height);
            rings.forEach(ring => {
                ring.material.resolution.copy(res);
            });

            // Composer 크기 업데이트
            composer.setSize(width, height);
        });

        animate();

        // --- 6. 오디오 및 상호작용 (Audio & Interaction) ---
        let audioCtx = null;
        const overlay = document.getElementById('overlay');
        let currentChordIndex = 0;

        // 코드 진행 정의: Verse 1, Chorus, Verse 2, Chorus
        const progression = [
            // Verse 1
            [65.41, 155.56, 196, 261.63],   // Cm (C2, Eb3, G3, C4)
            [87.31, 207.65, 261.63, 349.23], // Fm (F2, Ab3, C4, F4)
            [58.27, 146.83, 174.61, 233.08], // Bb (Bb1, D3, F3, Bb3)
            [77.78, 196, 233.08, 311.13],    // Eb (Eb2, G3, Bb3, Eb4)
            [73.42, 174.61, 207.65, 293.66],  // Ddim (D2, F3, Ab3, D4)
            [123.47, 146.83, 196, 246.94],   // G/B (B2, D3, G3, B3)
            [65.41, 155.56, 196, 261.63],    // Cm
            [73.42, 174.61, 233.08, 293.66],  // Bb/D (D2, F3, Bb3, D4)
            [77.78, 196, 233.08, 311.13],    // Eb
            [103.83, 130.81, 155.56, 207.65], // Ab (Ab2, C3, Eb3, Ab3)
            [87.31, 207.65, 261.63, 349.23], // Fm
            [58.27, 146.83, 174.61, 233.08],  // Bb
            [98, 123.47, 146.83, 196],        // G (G2, B2, D3, G3)
            
            // Chorus
            [65.41, 155.56, 196, 261.63],    // Cm
            [73.42, 174.61, 233.08, 293.66],  // Bb/D
            [77.78, 196, 233.08, 311.13],    // Eb
            [103.83, 130.81, 155.56, 207.65], // Ab
            [87.31, 207.65, 261.63, 349.23], // Fm
            [77.78, 196, 261.63, 311.13],    // Cm/Eb (Eb2, G3, C4, Eb4)
            [73.42, 174.61, 207.65, 293.66],  // Ddim
            [98, 123.47, 146.83, 174.61],    // G7 (G2, B2, D3, F3)
            [65.41, 155.56, 196, 261.63],    // Cm
            [58.27, 146.83, 174.61, 233.08], // Bb
            [77.78, 196, 233.08, 311.13],    // Eb
            [73.42, 174.61, 207.65, 293.66],  // Ddim
            [87.31, 207.65, 261.63, 349.23], // Fm
            [65.41, 155.56, 196, 261.63],    // Cm
            [98, 130.81, 155.56, 196],       // Cm/G (G2, C3, Eb3, G3)
            [98, 123.47, 146.83, 174.61],    // G7
            [65.41, 155.56, 196, 261.63],    // Cm
            
            // Verse 2
            [87.31, 207.65, 261.63, 349.23], // Fm
            [58.27, 146.83, 174.61, 233.08], // Bb
            [77.78, 196, 233.08, 311.13],    // Eb
            [73.42, 174.61, 207.65, 293.66],  // Ddim
            [98, 123.47, 146.83, 174.61],    // G7
            [65.41, 155.56, 196, 261.63],    // Cm
            [73.42, 174.61, 233.08, 293.66],  // Bb/D
            [77.78, 196, 233.08, 311.13],    // Eb
            [103.83, 130.81, 155.56, 207.65], // Ab
            [87.31, 207.65, 261.63, 349.23], // Fm
            [58.27, 146.83, 174.61, 233.08], // Bb
            [98, 123.47, 146.83, 174.61],    // G7
            
            // Chorus (반복)
            [65.41, 155.56, 196, 261.63],    // Cm
            [73.42, 174.61, 233.08, 293.66],  // Bb/D
            [77.78, 196, 233.08, 311.13],    // Eb
            [103.83, 130.81, 155.56, 207.65], // Ab
            [87.31, 207.65, 261.63, 349.23], // Fm
            [77.78, 196, 261.63, 311.13],    // Cm/Eb
            [73.42, 174.61, 207.65, 293.66],  // Ddim
            [98, 123.47, 146.83, 174.61],    // G7
            [65.41, 155.56, 196, 261.63],    // Cm
            [58.27, 146.83, 174.61, 233.08], // Bb
            [77.78, 196, 233.08, 311.13],    // Eb
            [73.42, 174.61, 207.65, 293.66],  // Ddim
            [87.31, 207.65, 261.63, 349.23], // Fm
            [65.41, 155.56, 196, 261.63],    // Cm
            [98, 130.81, 155.56, 196],       // Cm/G
            [98, 123.47, 146.83, 174.61],    // G7
            [65.41, 155.56, 196, 261.63]     // Cm
        ];

        // 피아노 느낌의 슬픈 코드 재생 함수
        function playSadChord(chordFrequencies) {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;
            
            chordFrequencies.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                // 톱니파와 사인파를 섞어 피아노의 배음 느낌을 흉내냄
                osc.type = i === 0 ? 'sine' : 'triangle'; 
                osc.frequency.setValueAtTime(freq, now);

                // 저역 통과 필터로 부드럽고 무거운 소리 연출
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(400, now);
                filter.Q.setValueAtTime(1, now);

                // Envelope (ADSR): 쿵 하고 나서 서서히 사라짐
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.05); // Attack
                gain.gain.exponentialRampToValueAtTime(0.001, now + 4.0); // Release

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(now);
                osc.stop(now + 4.0);
            });
        }

        overlay.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            overlay.classList.add('hidden');
            
            // 첫 클릭 시 바로 한 번 연주
            playSadChord(progression[currentChordIndex]);
            triggerBloomPulse();
            triggerRingPulse();
            currentChordIndex = (currentChordIndex + 1) % progression.length;
        });

        // 캔버스/문서 클릭 이벤트: 클릭할 때마다 코드 한 번씩 진행
        document.addEventListener('click', () => {
            if (!overlay.classList.contains('hidden')) return;

            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }

            playSadChord(progression[currentChordIndex]);
            triggerBloomPulse();
            triggerRingPulse();
            currentChordIndex = (currentChordIndex + 1) % progression.length;
        });
        // -----------------------------------------------------
    </script>
</body>
</html>
